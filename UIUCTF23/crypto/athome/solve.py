e = 359050389152821553416139581503505347057925208560451864426634100333116560422313639260283981496824920089789497818520105189684311823250795520058111763310428202654439351922361722731557743640799254622423104811120692862884666323623693713
n = 26866112476805004406608209986673337296216833710860089901238432952384811714684404001885354052039112340209557226256650661186843726925958125334974412111471244462419577294051744141817411512295364953687829707132828973068538495834511391553765427956458757286710053986810998890293154443240352924460801124219510584689
c = 67743374462448582107440168513687520434594529331821740737396116407928111043815084665002104196754020530469360539253323738935708414363005373458782041955450278954348306401542374309788938720659206881893349940765268153223129964864641817170395527170138553388816095842842667443210645457879043383345869

# ChatGPT to the rescue https://chat.openai.com/share/098d781b-5145-435e-8689-26abe7b6aa90

def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

def extendedEuclidean(a, b):
    if b == 0:
        return (a, 1, 0)
    d, x1, y1 = extendedEuclidean(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return (d, x, y)

def modular_inverse(e, n):
    d, x, y = extendedEuclidean(e, n)
    if d != 1:
        raise ValueError("Modular inverse does not exist")
    if x < 0:
        x += n
    return x

def solve_for_x(c, e, n):
    x = (c * modular_inverse(e, n)) % n
    return x

flag = solve_for_x(c, e, n)
flag_bytes = flag.to_bytes((flag.bit_length() + 7) // 8, "big")
flag_str = flag_bytes.decode()
print("Flag:", flag_str)

